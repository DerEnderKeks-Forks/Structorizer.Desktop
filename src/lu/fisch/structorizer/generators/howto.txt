How To Write a Generator
========================

1	Derive a new subclass of lu.fisch.structorizer.generators.Generator.
2	Implement the abstract configuration methods:
	2.1	getDialogTitle()
		Return a title string for the FileChooser dialog (in English!),
		usually "Export (language name) ..."
	2.2	getFileDescription()
		Return a string to be used by the file filter for the FileChooser
		dialog.
	2.3	getFileExtensions()
		Return a string array (type String[]) containing all source code
		file name extensions (without dot!) to be accepted by the file
		filter, e.g. {"cc", "cpp"} for C++.
	2.4	getIndent()
		Return a string to be used for a one-level indentation in the
		source, usually	either a tab character or a sequence of space
		characters.
	2.5	getCommentSymbolLeft()
		Return a string, which opens a delimited comment (e.g. "/*") or
		is used to start a line comment in the target language (e.g. "//"
		for C++). Make sure the non-abstract method getCommentRight() is
		configured accordingly.
	2.6	getCommentSymbolRight()
		Is not abstract but pre-configured to return an empty string,
		which is perfect for line comments. If the target language doesn't
		know line comments or if getCommentLeft() returns the left delimiter
		of a delimited comment, then you must return the corresponding right
		delimiter here, e.g. "*/".
	2.7	getInputReplacer(boolean withPrompt)
		Depending on the value of withPrompt return
		true)	a regular substitution pattern for input instructions
				representing an instruction sequence where substring
				"$1" marks the position	where to insert the prompt
				string and substring "$2" marks the position where to
				place the name of the variable to be input, e.g.
				"printf($1); scanf(\"\", &$2)" for C;
		false)	a regular substitution pattern for an input instruction
				without output of a prompt where "$1" marks the place
				to insert the variable name, e.g. "std::cin >> $1" for
				C++.
		The returned pattern should not end with an instruction separator.
	2.8	getOutputReplacer()
		Return the regular replacement pattern representing an output
		instruction causing a line feed in the end, where a substring "$1"
		marks the place where the transformed output expression (assume
		a single expression here, see later below) is to be placed , e.g.
		"std::cout << $1 << std::endl" for C++.
	2.9	getReservedWords()
		Return a string array (type String[]) containing the reserved
		words of the target language (also see isCaseSignificant()).
	2.10	isCaseSignificant()
		Return true if case matters for identifying reserved words
		(also see getReservedWords() above) in the target language 
		(e.g. true for Java, false for Pascal).
	2.11	breakMatchesCase()
		Specify whether an instruction to leave a loop (the innermost
		enclosing loop) like "break;" in C is available in the target
		language AND ALSO BREAKS CASE SELECTIONS (switch constructs).
		Return true if snd only there is an insruction that does both.
3	Override the substantial generator methods.
	3.0	General remarks
		There is a method for each structogram element type, obtaining
		the element and the current indentation string as arguments.
		Each of the generateCode methods is to recursively translate
		the structure and its contents to lines of code, which are to
		be appended to the generator's inherited code member (being a
		StringList object). The base class Generator provides bare method
		skeletons showing how to do the recursive descending. On
		overriding these methods you may start from a copy of them and
		fill it with "flesh". Usually the first action of the method
		will be to add the element comment to the code, using method
		insertComment(Element element, String _indent); see sections 5
		and	beyond for helper methods and further customization
		opportunities. You will have to respect several export options
		explained in section 4. You will find a lot of examples in the
		existing Generator subclasses.
	3.1	generateCode(Instruction _inst, String _indent)
		Is to generate the code for the given basic instruction element.
		The code schould be enclosed by the following construct:
		if (!insertAsComment(_inst, _indent)) {
			// place actual generator code here
		}
		To translate the instruction you will now fetch the element text
		by _inst.getText() and translate it line for line.
		Class Instruction provides some line-classifying methods like:
		boolean isDeclaration(String line),
		boolean isAssignment(String line),
		boolean isInput(String line),
		boolean isEmptyInput(String line),
		boolean isOutput(String line), or
		boolean isTurtleizerMove(String line).
	3.2	generateCode(Alternative _alt, Strin _indent)
		Is to generate the code for the given alternative element,
		including its branches (_alt.gTrue, _alt.qFalse), which are
		to handled by recursive calls of generateCode() at the
		appropriate place.
	3.3	generateCode(Case _case, String _indent)
		Is to generate the code for the given alternative element,
		including its branches, which are elements of the Subqueue
		Vector _case.qs and to be handled by recursive calls of
		generateCode(). For the structure of the element text see
		Structorizer User Guide and compare the existing Generator
		subclasses.
	3.4	generateCode(For _for, String _indent)
		A good idea is first to classify the loop style and to delegate
		the handling of FOR-IN loops (aka foreach loops) to another
		method:
		if (_for.isForInLoop())
		{
			// Method generateForInCode returns false if it doesn't
			// cope with the loop structure or decides that it isn't
			// actually a FOR-IN loop but should be handled as ordinary
			// FOR loop
			if (generateForInCode(_for, _indent)) return;
		}
		The rest is straightforward. You may make use of the following
		helper methods of the For element class (for counting loops):
		String For.getCounterVar(),
		String For.getStartValue(),
		String For.getEndValue(),
		int For.getStepConst().
		For FOR-IN loops there are some other helper methods:
		String For.getCounterVar(),
		StringList Generator.extractForInListItems(For _for)
		To replace a non-supported FOR-IN list by an equivalent
		algorithm structure may be tricky, but there are several
		elaborate code examples in various Generater subclasses.
	3.5	generateCode(While _while, String _insert)
		A specific support for exit jumps is provided by the jumpTable
		inherited and prepared by the base Generator class. It may be
		used to generate jump labels (see generateCode(Jump, String)).
	3.6	generateCode(Repeat _repeat, String _insert)
		A specific support for exit jumps is provided by the jumpTable
		inherited and prepared by the base Generator class. It may be
	3.7	generateCode(Forever _forever, String _insert)
		A specific support for exit jumps is provided by the jumpTable
		inherited and prepared by the base Generator class. It may be
	3.8	generateCode(Call _call, String _insert)
		Class Call offers classifying and identifying methods:
		boolean Call.isAssignment(String line),
		boolean Call.isProcedureCall(String line),
		boolean Call.isFunctionCall(String line),
		Function getCalledRoutine() - works only for single-line Calls.
	3.9	generateCode(Jump _jump, String _indent)
		Class Jump still doesn't offer some classifying methods (is
		planned, though) such that the generator must classify leave,
		return, and exit jumps itself. Even more imortant is the
		jumpTable member inherited from and automatically prepared by
		the Generator base class: it maps Jump elements and elements
		left by a jump to reference ids such that both can be matched
		easily or unique jump labels may be derived from.
	3.10	generateCode(Parallel _para, String _indent)
		Depending on whether the language supports concurrency either
		a working multithreading section should be derived or at least
		a sequential concatenation of the parallel branches is to be
		produced, ideally marked with bold comments (see examples in
		the Generator subclasses).
	3.11	generateCode(Root, String _indent)
		This method builds the outer code framework for the algorithm
		(i.e. the program, procedure or function definition), usually
		consisting of the header, a "preamble" (containing e.g. variable
		delarations), the implementation part, the result compilation,
		and a footer. See Generator.generateCode(Root, String) for the
		general template. Now you have two options:
		a)	Either you may override generateCode(Root, String) as a
			whole if the substructure template doesn't suit your
			target language needs,
		b)	or you may leave the base method as is and override the
			submethods (see their Java doc and the exaples you may
			find in various Generator subclasses):
			String generateHeader(Root, ...),
			String generatePreamble(Root, ...),
			String generateResult(Root, ...),
			void generateFooter(Root, ...).
4.	Export options and other preferences to be considered
	(TODO)
5.	Helper methods for element text transformation
	The most important helper methods are:
	String transform(String) with several submethods
	void insertComment(Element _ele, String _indent)
	void insertComment(String _comment, String _indent)
	boolean insertAsComment(Element _ele, String _indent)
	void code.add(String line)
	void addCode(String text, String _indent, boolean asComment)
	...
	(TODO to be continued and explained)
6.	Setup to support the FileAPI
	(TODO)
7.	Add the generator to the plugin configuration
	Find the resource file generators.xml in the ...structorizer.gui
	source directory and add a new <plugin> entry with a title string
	for the export menu and the fully qualified class name of the new
	generator. (For future enhancement, an icon attribute is prepared
	but still not used for the menu. So best is to leave it empty.
