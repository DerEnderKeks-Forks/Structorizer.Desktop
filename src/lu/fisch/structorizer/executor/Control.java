/*
    Structorizer
    A little tool which you can use to create Nassi-Schneiderman Diagrams (NSD)

    Copyright (C) 2009  Bob Fisch

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or any
    later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package lu.fisch.structorizer.executor;

/******************************************************************************************************
 *
 *      Author:         Bob Fisch
 *
 *      Description:    This class represents the GUI controlling the execution of a diagram.
 *
 ******************************************************************************************************
 *
 *      Revision List
 *
 *      Author          Date			Description
 *      ------			----			-----------
 *      Bob Fisch       2009.05.18      First Issue
 *      Kay Gürtzig     2015.11.05      Enhancement allowing to adopt edited values from Control (KGU#68)
 *      Kay Gürtzig     2015.11.14      New controls to display the call level for enhancement #9 (KGU#2)
 *      Kay Gürtzig     2016.03.06      Enh. #77: New checkboxes for test coverage tracking mode (KGU#117)
 *      Kay Gürtzig     2016.03.13      Enh. #124 (KGU#156): Runtime data collection generalised
 *      Kay Gürtzig     2016.03.17      Enh. #133 (KGU#159): Stack trace may now be shown in paused mode
 *      Kay Gürtzig     2016.03.18      KGU#89: Extended Language translation support
 *      Kay Gürtzig     2016.03.25      Message translations now held in LangTextHolder instead of JLabel
 *      Kay Gürtzig     2016.04.12      Enh. #137: additional toggle to direct input and output to a text window
 *      Kay Gürtzig     2016.05.05      KGU#197: Further (forgotten) LangTextHolders added
 *      Kay Gürtzig     2016.07.25      Issue #201: Redesign of the GUI, new Slider listening, Call Stack button
 *      Kay Gürtzig     2016.07.27      KGU#197: More LangTextHolders for Executor error messages
 *      Kay Gürtzig     2016.08.03      KGU#89: Inheritance enhanced to improve language support (var table)
 *
 ******************************************************************************************************
 *
 *      Comment:  /
 *         
 ******************************************************************************************************///



import java.awt.Color;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.Vector;

import javax.swing.JComboBox;
import javax.swing.SwingUtilities;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.table.DefaultTableModel;

import lu.fisch.structorizer.arranger.Arranger;
import lu.fisch.structorizer.elements.Element;
import lu.fisch.structorizer.elements.RuntimeDataPresentMode;
import lu.fisch.structorizer.gui.IconLoader;
import lu.fisch.structorizer.gui.LangTextHolder;
import lu.fisch.structorizer.locales.LangFrame;


/**
 *
 * @author robertfisch
 */
@SuppressWarnings("serial")
public class Control extends LangFrame implements PropertyChangeListener, ItemListener { //, ILangDialog {

    /** Creates new form Control */
    public Control() {
        initComponents();
        this.setDefaultCloseOperation(Control.DO_NOTHING_ON_CLOSE);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     * @param new java.awt.event.Mouse 
     */
    //@SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

    	// START KGU#89 2015-11-25
    	this.setIconImage(IconLoader.ico004.getImage());
    	// END KGU#89 2015-11-25
    	// START KGU#210 2016-07-25: Initialisation with min, max, and value
        //slSpeed = new javax.swing.JSlider();
        slSpeed = new javax.swing.JSlider(0, 2000, 50);
        // END KGU#210 2016-07-25
        lblSpeed = new javax.swing.JLabel();
        // START KGU#89 2015-11-25
        lblSpeedValue = new javax.swing.JLabel();
        // END KGU#89 2015-11-25
        // START KGU#160 2016-04-12: Enh. #137 - Checkbox for text window output
        chkOutputToTextWindow = new javax.swing.JCheckBox("Text Window Output");
        // END KGU#160 2016-04-12
        // START KGU#117 2016-03-06: Enh. #77 - Checkbox for Run data collection
        chkCollectRuntimeData = new javax.swing.JCheckBox("Collect Run Data");
        cbRunDataDisplay = new JComboBox<RuntimeDataPresentMode>(RuntimeDataPresentMode.values());
        // END KGU#117 2016-03-06
        btnStop = new javax.swing.JButton();
        btnPlay = new javax.swing.JButton();
        btnPause = new javax.swing.JButton();
        btnStep = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        tblVar = new HeaderTable();
        // START KGU#2 (#9) 2015-11-14: Additional display of subroutine call level
        // START KGU#210 2016-07-25: Fix #210 - improved usability
        //lblCallLevel = new javax.swing.JLabel(" Subroutine level:");
        btnCallStack = new javax.swing.JButton("Call stack");
        lblCallLevel = new javax.swing.JLabel("Level:");
        // END KGU#210 2016-07-25
        txtCallLevel = new javax.swing.JTextField("0");
        txtCallLevel.setEditable(false);
        // END KGU#2 (#9) 2015-11-14

        // START KGU#89/KGU#157 2016-03-18: Bugfix #131 - Prevent interference or take-over
        // These fields are just a translation support for Executor
        lbStopRunningProc = new LangTextHolder("This action is not allowed while a diagram is being executed.\nDo you want to stop the current execution?");
        lbInputValue = new LangTextHolder("Please enter a value for <%>");
        lbInputPaused = new LangTextHolder("Execution paused - you may enter the value in the variable display.");
        // END KGU#89/KGU#157 2016-03-18
        // START KGU#197 2016-05-05: Forgotten translations added
        lbInputCancelled = new LangTextHolder("Input cancelled");
        lbManuallySet = new LangTextHolder("*** Manually set: %1 <- %2 ***");
        lbEmptyLine = new LangTextHolder("empty line");
        lbReturnedResult = new LangTextHolder("Returned result");
        lbOutput = new LangTextHolder("Output");
        lbInput = new LangTextHolder("Input");
        lbAcknowledge = new LangTextHolder("Please acknowledge.");
        // END KGU#197 2016-05-05

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        // START KGU#210 2016-07-25: Issue #201 - show more details
        //slSpeed.setMajorTickSpacing(100);
        //slSpeed.setMaximum(2000);
        slSpeed.setMajorTickSpacing(500);
        slSpeed.setMinorTickSpacing(50);
        slSpeed.setPaintTicks(true);
        slSpeed.setPaintLabels(true);
        // END KGU#201 2016-07-25
        // START KGU#210 2016-07-25: Issue #201 - Cursor key movements didn't immedialtely show
        slSpeed.addChangeListener(new ChangeListener() {
        	public void stateChanged(ChangeEvent e) {
                javax.swing.JSlider source = (javax.swing.JSlider)e.getSource();
                if (!source.getValueIsAdjusting()) {
                	updateSpeed();
                }
        	}    

        });
        // END KGU#210 2016-07-25
        slSpeed.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                slSpeedMouseMoved(evt);
            }
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                slSpeedMouseDragged(evt);
            }
        });
        // START KGU#210 2016-07-25: Issue #201 - subsumed by ChangeListener
//        slSpeed.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
//            public void propertyChange(java.beans.PropertyChangeEvent evt) {
//                slSpeedPropertyChange(evt);
//            }
//        });
//        slSpeed.addInputMethodListener(new java.awt.event.InputMethodListener() {
//            public void inputMethodTextChanged(java.awt.event.InputMethodEvent evt) {
//            }
//            public void caretPositionChanged(java.awt.event.InputMethodEvent evt) {
//                slSpeedCaretPositionChanged(evt);
//            }
//        });
//        slSpeed.addMouseListener(new java.awt.event.MouseAdapter() {
//            public void mouseReleased(java.awt.event.MouseEvent evt) {
//                slSpeedMouseReleased(evt);
//            }
//            public void mouseClicked(java.awt.event.MouseEvent evt) {
//                slSpeedMouseClicked(evt);
//            }
//            public void mouseExited(java.awt.event.MouseEvent evt) {
//                slSpeedMouseExited(evt);
//            }
//        });
//        slSpeed.addMouseWheelListener(new java.awt.event.MouseWheelListener() {
//            public void mouseWheelMoved(java.awt.event.MouseWheelEvent evt) {
//                slSpeedMouseWheelMoved(evt);
//            }
//        });
        // END KGU#210 2016-07-25
        tblVar.addPropertyChangeListener(this);

        //lblSpeed.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        // START KGU#89 2015-11-25
        //lblSpeed.setText(" Delay: 50");
        lblSpeed.setText(" Delay: ");
        
        lblSpeedValue.setText("50");
        // END KGU#89 2015-11-25
        
		// START KGU#160 2016-04-12: Enh. #137 - Checkbox for text window output
        chkOutputToTextWindow.addItemListener(this);
		// END KGU#160 2016-04-12

		// START KGU#117 2016-03-06: Enh. #77 Track test coverage mode change
        chkCollectRuntimeData.addItemListener(this);
        // END KGU#117 2016-03-06
        // START KGU#165 2016-03-13: Enh. #124
        cbRunDataDisplay.addItemListener(this);
        // Now fix the element height, the width may stay extensible
        //cbRunDataDisplay.setMaximumSize(
        //		new Dimension(Short.MAX_VALUE, cbRunDataDisplay.getPreferredSize().height));
        // END KGU#156 2016-03-13

        btnStop.setIcon(new javax.swing.ImageIcon(getClass().getResource("/lu/fisch/structorizer/executor/stop.png"))); // NOI18N
        btnStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStopActionPerformed(evt);
            }
        });

        btnPlay.setIcon(new javax.swing.ImageIcon(getClass().getResource("/lu/fisch/structorizer/executor/play.png"))); // NOI18N
        btnPlay.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPlayActionPerformed(evt);
            }
        });

        btnPause.setIcon(new javax.swing.ImageIcon(getClass().getResource("/lu/fisch/structorizer/executor/pause.png"))); // NOI18N
        btnPause.setEnabled(false);
        btnPause.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnPauseActionPerformed(evt);
            }
        });

        btnStep.setIcon(new javax.swing.ImageIcon(getClass().getResource("/lu/fisch/structorizer/executor/next.png"))); // NOI18N
        btnStep.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnStepActionPerformed(evt);
            }
        });

        // START KGU#159 2016-03-17: New possibility to show stacktrace in paused mode by double-click
//        txtCallLevel.addMouseListener(new java.awt.event.MouseAdapter() {
//            public void mouseReleased(java.awt.event.MouseEvent evt) {}
//            public void mouseClicked(java.awt.event.MouseEvent evt) {
//                txtCallLevelClicked(evt);
//            }
//			public void mouseExited(java.awt.event.MouseEvent evt) {}
//        });
//        txtCallLevel.setToolTipText("Call stack depth. Double-click to see the Call stack content (only on paused execution).");
        btnCallStack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                btnCallStackActionPerformed(evt);
            }
        });
        // END KGU#159 2016-03-17

        tblVar.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "Name", "Content"
            }
        ) {
            Class<?>[] types = new Class<?> [] {
                java.lang.String.class, java.lang.Object.class
            };

            public Class<?> getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        jScrollPane1.setViewportView(tblVar);
        
//        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
//        getContentPane().setLayout(layout);
//        layout.setHorizontalGroup(
//            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
//            .add(layout.createSequentialGroup()
//                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
//                	// START KGU#89 2015-11-25: Speed label decomposed
//                    .add(layout.createSequentialGroup()
//                    	.add(lblSpeed /*, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 86, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE*/)
//                    	.add(lblSpeedValue/*, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 20, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE*/))
//                    // END KGU#89 2015-11-25
//                    // START KGU#160 2016-04-12: Enh. #137 - Checkbox for text window output
//                    .add(layout.createSequentialGroup().add(chkOutputToTextWindow))
//                    // END KGU#160 2016-04-12
//                    // START KGU#117 2016-03-06: Enh. #77
//                    .add(layout.createSequentialGroup().add(chkCollectRuntimeData))
//                    // END KGU#117 2016-03-06
//                    .add(layout.createSequentialGroup()
//                        .add(btnStop)
//                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
//                        .add(btnPlay))
//                        // START KGU#2 (#9) 2015-11-14
//                        .add(lblCallLevel))
//                        // END KGU#2 (#9) 2015-11-14
//                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
//                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
//                    	// START KGU#117 2016-03-06: Enh. #77
//                    .add(layout.createSequentialGroup().add(cbRunDataDisplay))
//                    	// END KGU#117 2016-03-06
//                    .add(layout.createSequentialGroup()
//                        .add(btnPause)
//                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
//                        .add(btnStep))
//                // START KGU#2 (#9) 2015-11-14
//                		.add(txtCallLevel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 120, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
//                // END KGU#2 (#9) 2015-11-14
//// START KGU 2015-10-12: preferred size enhanced from 83 to 120
//                    //.add(slSpeed, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 83, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
//                    .add(slSpeed, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 120, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
//// END KGU 2015-0-12
//                .add(jScrollPane1, 0, 0, Short.MAX_VALUE)
//        );
//        layout.setVerticalGroup(
//            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
//            .add(layout.createSequentialGroup()
//                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
//                    .add(lblSpeed, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 28, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
//                		// START KGU#89 2015-11-25: New, separate value label
//                    .add(lblSpeedValue, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 28, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
//                		// END KGU#89 2015-11-25
//                    .add(slSpeed, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
//                // START KGU#160 2016-04-12: Enh. #137 - Checkbox for text window output
//                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
//                .add(chkOutputToTextWindow)
//                // END KGU#160 2016-04-12
//                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
//                .add(layout.createParallelGroup()
//                    .add(chkCollectRuntimeData)
//                    .add(cbRunDataDisplay))
//                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
//                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
//                    .add(btnStop)
//                    .add(btnPlay)
//                    .add(btnPause)
//                    .add(btnStep))
//                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
//                // START KGU#2 (#9) 2015-11-14
//                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
//                		.add(lblCallLevel)
//                		.add(txtCallLevel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
//                // END KGU#2 (#9) 2015-11-14
//                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 236, Short.MAX_VALUE))
//        );

// START KGU#210 2016-07-25: Issue #201 - new GridBagLayout-based GUI
// Trouble is that the width gets unnecessarily large and reducing the width
// adds extra spaces between the lines - no idea how to suppress this. It seems
// that no specific component can be blamed.
        GridBagLayout gbl = new GridBagLayout();
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(3,2,2,2);
        Container ctnr = getContentPane();
        //JPanel ctnr = new JPanel();
        ctnr.setLayout(gbl);

        gbc.gridx = 1;
        gbc.gridy = 1;
        gbc.gridwidth = 1;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE;
        gbl.setConstraints(lblSpeed, gbc);
        //getContentPane().add(lblSpeed);
        ctnr.add(lblSpeed);
        
        gbc.gridx = 2;
        gbc.gridy = 1;
        gbc.gridwidth = GridBagConstraints.RELATIVE;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE;
        gbl.setConstraints(lblSpeedValue, gbc);
        //getContentPane().add(lblSpeedValue);
        ctnr.add(lblSpeedValue);
        
        gbc.gridx = 3;
        gbc.gridy = 1;
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        gbc.gridheight = 2;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE_LEADING;
        gbl.setConstraints(slSpeed, gbc);
        //getContentPane().add(slSpeed);
        ctnr.add(slSpeed);
        slSpeed.setMaximumSize(new Dimension(30, 15));
        
        gbc.gridx = 1;
        gbc.gridy = 2;
        gbc.gridwidth = 2;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE_LEADING;
        gbl.setConstraints(chkOutputToTextWindow, gbc);
        //getContentPane().add(chkOutputToTextWindow);
        ctnr.add(chkOutputToTextWindow);
        
        gbc.gridx = 1;
        gbc.gridy = 3;
        gbc.gridwidth = 2;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE_LEADING;
        gbl.setConstraints(chkCollectRuntimeData, gbc);
        //getContentPane().add(chkCollectRuntimeData);
        ctnr.add(chkCollectRuntimeData);
        
        gbc.gridx = 3;
        gbc.gridy = 3;
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE_LEADING;
        gbl.setConstraints(cbRunDataDisplay, gbc);
        //getContentPane().add(cbRunDataDisplay);
        ctnr.add(cbRunDataDisplay);
        
        gbc.gridx = 1;
        gbc.gridy = 4;
        gbc.gridwidth = 1;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.CENTER;
        gbl.setConstraints(btnStop, gbc);
        //getContentPane().add(btnStop);
        ctnr.add(btnStop);
        
        gbc.gridx = 2;
        gbc.gridy = 4;
        gbc.gridwidth = 1;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.CENTER;
        gbl.setConstraints(btnPlay, gbc);
        //getContentPane().add(btnPlay);
        ctnr.add(btnPlay);
        
        gbc.gridx = 3;
        gbc.gridy = 4;
        gbc.gridwidth = 1;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.CENTER;
        gbl.setConstraints(btnPause, gbc);
        //getContentPane().add(btnPause);
        ctnr.add(btnPause);
        
        gbc.gridx = 4;
        gbc.gridy = 4;
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 1;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.CENTER;
        gbl.setConstraints(btnStep, gbc);
        //getContentPane().add(btnStep);
        ctnr.add(btnStep);
        
        gbc.gridx = 1;
        gbc.gridy = 5;
        gbc.gridwidth = 2;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE_LEADING;
        gbl.setConstraints(btnCallStack, gbc);
        //getContentPane().add(lblCallLevel);
        ctnr.add(btnCallStack);
        
        gbc.gridx = 3;
        gbc.gridy = 5;
        gbc.gridwidth = 1;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE_LEADING;
        gbl.setConstraints(lblCallLevel, gbc);
        //getContentPane().add(lblCallLevel);
        ctnr.add(lblCallLevel);
        
        gbc.gridx = 4;
        gbc.gridy = 5;
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        gbc.gridheight = 1;
        gbc.fill = GridBagConstraints.HORIZONTAL;
        gbc.weightx = 0;
        gbc.weighty = 0;
        //gbc.anchor = GridBagConstraints.BASELINE_LEADING;
        gbl.setConstraints(txtCallLevel, gbc);
        //getContentPane().add(txtCallLevel);
        ctnr.add(txtCallLevel);
        
        gbc.gridx = 1;
        gbc.gridy = 6;
        gbc.gridwidth = GridBagConstraints.REMAINDER;
        //gbc.gridheight = GridBagConstraints.REMAINDER;
        gbc.fill = GridBagConstraints.BOTH;
        gbc.weightx = 0;
        gbc.weighty = 1;
        //gbc.anchor = GridBagConstraints.BASELINE_LEADING;
        gbl.setConstraints(jScrollPane1, gbc);
        //getContentPane().add(jScrollPane1);  
        ctnr.add(jScrollPane1);
// END KGU#210 2016-07-25
       
        //getContentPane().add(ctnr);

        pack();
        
        setSize(350, 500);
        
    }// </editor-fold>//GEN-END:initComponents

    public void init()
    {
        btnStop.setEnabled(true);
        btnPlay.setEnabled(true);
        btnPause.setEnabled(false);
        btnStep.setEnabled(true);
        // START KGU#210 2016-07-25: Issue #201 - new call stack display strategy
        btnCallStack.setEnabled(false);
        // END KGU#210 2016-07-25
        // START KGU#117 2016-03-06: Enh. #77
        chkCollectRuntimeData.setEnabled(true);
        this.cbRunDataDisplay.setEnabled(chkCollectRuntimeData.isSelected());
        // END KGU#117 2016-03-06
        // empty table
        DefaultTableModel tm = (DefaultTableModel) tblVar.getModel();
        while(tm.getRowCount()>0) tm.removeRow(0);
    }

    // START KGU#210/KGU#234 2016-08-09: Issue #224 - Ensure GUI consistency and table grid visibility
    public void updateLookAndFeel()
    {
    	try {
    		SwingUtilities.updateComponentTreeUI(this);
    		// Now, this is a workaround for issue #224
    		if (!javax.swing.UIManager.getLookAndFeel().getName().equals("Nimbus"))
    		{
    			tblVar.setShowGrid(true);
    		}
    	}
    	catch (Exception ex) {}
    }
    // END KGU#210/KGU#234 2016-08-09
    
    private void btnStopActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_btnStopActionPerformed
    {//GEN-HEADEREND:event_btnStopActionPerformed
        Executor.getInstance().setStop(true);
        // START KGU#117 2016-03-06: Enh. #77
        chkCollectRuntimeData.setEnabled(true);
        cbRunDataDisplay.setEnabled(chkCollectRuntimeData.isSelected());
        // END KGU#117 2016-03-06
        this.setVisible(false);
    }//GEN-LAST:event_btnStopActionPerformed

    private void btnPlayActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_btnPlayActionPerformed
    {//GEN-HEADEREND:event_btnPlayActionPerformed
        btnPause.setEnabled(true);
        btnPlay.setEnabled(false);
        btnStep.setEnabled(false);
        // START KGU#210 2016-07-25: Issue #201 - new Call Stack display strategy
        btnCallStack.setEnabled(false);
        // END KGU#210 2016-07-25
        // START KGU#117 2016-03-06: Enh. #77
        chkCollectRuntimeData.setEnabled(false);
        cbRunDataDisplay.setEnabled(chkCollectRuntimeData.isSelected());
        // END KGU#117 2016-03-06
        // START KGU#68 205-11-06: Enhancement - update edited values
    	if (varsUpdated)
    	{
    		Executor.getInstance().adoptVarChanges(varUpdates);
    	}
    	varsUpdated = false;
    	// END KGU#68 2015-11-06
        if(Executor.getInstance().isRunning()==false)
        {
            Executor.getInstance().start(false);
        }
        else
        {
            Executor.getInstance().setPaus(false);
        }
    }//GEN-LAST:event_btnPlayActionPerformed
    
    // START KGU 2015-10-12: Must be possible on breakpoints
    public void setButtonsForPause()
    {
        btnPause.setEnabled(false);
        btnPlay.setEnabled(true);
        btnStep.setEnabled(true);
        // START KGU#210 2016-07-25: Issue #201 - new Call stack display strategy
        btnCallStack.setEnabled(true);
        // END KGU#210 2016-07-25
    }
    // END KGU 2015-10-12

    private void btnPauseActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_btnPauseActionPerformed
    {//GEN-HEADEREND:event_btnPauseActionPerformed
    	// START KGU 2015-10-12
//        btnPause.setEnabled(false);
//        btnPlay.setEnabled(true);
//        btnStep.setEnabled(true);
    	setButtonsForPause();
    	// END KGU 2015-10-12
        Executor.getInstance().setPaus(!Executor.getInstance().getPaus());
    }//GEN-LAST:event_btnPauseActionPerformed

    private void btnStepActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_btnStepActionPerformed
    {//GEN-HEADEREND:event_btnStepActionPerformed
    	// START KGU#68 2015-11-06: Enhancement - update edited values
    	if (varsUpdated)
    	{
    		Executor.getInstance().adoptVarChanges(varUpdates);
    		varsUpdated = false;
    	}
    	// END KGU#68 2015-11-06
        // START KGU#117 2016-03-06: Enh. #77
        chkCollectRuntimeData.setEnabled(false);
        cbRunDataDisplay.setEnabled(chkCollectRuntimeData.isSelected());
        // END KGU#117 2016-03-06
        if(Executor.getInstance().isRunning()==false)
        {
            Executor.getInstance().start(true);
        }
        else
        {
            Executor.getInstance().doStep();
        }
    }//GEN-LAST:event_btnStepActionPerformed

    private void updateSpeed()
    {
        if(Executor.getInstance()!=null)
        {
            Executor.getInstance().setDelay(slSpeed.getValue());
        }
        // START KGU#89 2015-11-25
        //lblSpeed.setText(" Delay: "+slSpeed.getValue());
        lblSpeedValue.setText("" + slSpeed.getValue());
        // END KGU#89 2015-11-25
    }

    // START KGU#210 2016-07-25: Issue #201 - No longer needed
//    private void slSpeedCaretPositionChanged(java.awt.event.InputMethodEvent evt)//GEN-FIRST:event_slSpeedCaretPositionChanged
//    {//GEN-HEADEREND:event_slSpeedCaretPositionChanged
//        updateSpeed();
//    }//GEN-LAST:event_slSpeedCaretPositionChanged
//
//    private void slSpeedPropertyChange(java.beans.PropertyChangeEvent evt)//GEN-FIRST:event_slSpeedPropertyChange
//    {//GEN-HEADEREND:event_slSpeedPropertyChange
//        updateSpeed();
//    }//GEN-LAST:event_slSpeedPropertyChange
//
//    private void slSpeedMouseClicked(java.awt.event.MouseEvent evt)//GEN-FIRST:event_slSpeedMouseClicked
//    {//GEN-HEADEREND:event_slSpeedMouseClicked
//        // TODO add your handling code here:
//    }//GEN-LAST:event_slSpeedMouseClicked
//
//    private void slSpeedMouseExited(java.awt.event.MouseEvent evt)//GEN-FIRST:event_slSpeedMouseExited
//    {//GEN-HEADEREND:event_slSpeedMouseExited
//        updateSpeed();
//    }//GEN-LAST:event_slSpeedMouseExited
    // END KGU#210 2016-07-25

    private void slSpeedMouseMoved(java.awt.event.MouseEvent evt)//GEN-FIRST:event_slSpeedMouseMoved
    {//GEN-HEADEREND:event_slSpeedMouseMoved
        updateSpeed();
    }//GEN-LAST:event_slSpeedMouseMoved

    private void slSpeedMouseDragged(java.awt.event.MouseEvent evt)//GEN-FIRST:event_slSpeedMouseDragged
    {//GEN-HEADEREND:event_slSpeedMouseDragged
        updateSpeed();
    }//GEN-LAST:event_slSpeedMouseDragged

    // START KGU#210 2016-07-25: Issue #201 - No longer needed
//    private void slSpeedMouseWheelMoved(java.awt.event.MouseWheelEvent evt)//GEN-FIRST:event_slSpeedMouseWheelMoved
//    {//GEN-HEADEREND:event_slSpeedMouseWheelMoved
//        // TODO add your handling code here:
//    }//GEN-LAST:event_slSpeedMouseWheelMoved
//
//    private void slSpeedMouseReleased(java.awt.event.MouseEvent evt)//GEN-FIRST:event_slSpeedMouseReleased
//    {//GEN-HEADEREND:event_slSpeedMouseReleased
//        updateSpeed();
//    }//GEN-LAST:event_slSpeedMouseReleased
    // END KGU#210 2016-07-25

    // START KGU#159 2016-03-17: Stacktrace now permanently available on demand
    // START KGU#210 2016-07-25: Fix #201 - improved usability
    //private void txtCallLevelClicked(MouseEvent evt)
    //{
    //	if (evt.getClickCount() == 2 && Executor.getInstance().getPaus())
    //	{
    //		Executor.getInstance().showStackTrace();
    //	}
    //}
    private void btnCallStackActionPerformed(java.awt.event.ActionEvent evt)
    {
    	if (Executor.getInstance().getPaus())
    	{
    		Executor.getInstance().showStackTrace();
    	}    	
    }
    // END KGU
    // END KGU#159 2016-03-17

    public void updateVars(Vector<Vector<Object>> vars)
    {
    	// START KGU#68 2015-11-06: We want to keep track of changed variables
    	this.varsUpdated = false;
    	// END KGU#68 2015-11-06
        tblVar.setGridColor(Color.LIGHT_GRAY);
        tblVar.setShowGrid(true);
        DefaultTableModel tm = (DefaultTableModel) tblVar.getModel();
        // empty the table
        while(tm.getRowCount()>0) tm.removeRow(0);
        // START KGU#68 2015-11-06: Preparation for variable editing
        //for(int i=0;i<vars.size();i++) tm.addRow(vars.get(i));
        varUpdates = new Object[vars.size()];
        for(int i=0; i<vars.size(); i++)
        {
        	tm.addRow(vars.get(i));
        	varUpdates[i] = null;
        }
        // END KGU#68 2015-11-06
    }
    
    // START KGU#2 (#9) 2015-11-14: Update method for subroutine level display
    public void updateCallLevel(int level)
    {
    	this.txtCallLevel.setText(Integer.toString(level));
    }
    // END KGU#2 (#9) 2015-11-14

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnPause;
    private javax.swing.JButton btnPlay;
    private javax.swing.JButton btnStep;
    private javax.swing.JButton btnStop;
    private javax.swing.JScrollPane jScrollPane1;
    public javax.swing.JLabel lblSpeed;
    // START KGU#89 2015-11-25: Is to ease localization (separate text and value)
    private javax.swing.JLabel lblSpeedValue;
    // END KGU#49 2015-11-25
    private javax.swing.JSlider slSpeed;
    // START KGU#160 2016-04-12: Enh. #137 - Checkbox for text window output
    public javax.swing.JCheckBox chkOutputToTextWindow;
    // END KGU#160 2016-04-12
    // START KGU#117/KGU#156 2016-03-13: Enh. #77/#124 - Checkbox fpr Test coverage mode
    public javax.swing.JCheckBox chkCollectRuntimeData;
    public javax.swing.JComboBox<RuntimeDataPresentMode> cbRunDataDisplay;
    // END KGU#117/KGU#156 2016-03-13
    private HeaderTable tblVar;
    // End of variables declaration//GEN-END:variables
    // START KGU#2 (#9) 2015-11-14: Additional display of subroutine call level
    // START KGU#210 2016-07-25: Fix #201 - A button would be more obvious to display
    public javax.swing.JButton btnCallStack;
    // END KGU#210 2016-07-25
    public javax.swing.JLabel lblCallLevel;
    public javax.swing.JTextField txtCallLevel;
    // END KGU#2 (#9) 2015-11-14
    // START KGU#89/KGU#157 2016-03-18: Bugfix #131 - Language support for Executor
    public LangTextHolder lbStopRunningProc;
    public LangTextHolder lbInputValue;
    public LangTextHolder lbInputPaused;
    // END KGU#89/KGU#157 2016-03-18
    // START KGU#197 2016-05-05: More language support
    public LangTextHolder lbInputCancelled;
    public LangTextHolder lbManuallySet;
    public LangTextHolder lbEmptyLine;
    public LangTextHolder lbReturnedResult;
    public LangTextHolder lbOutput;
    public LangTextHolder lbInput;
    public LangTextHolder lbAcknowledge;
    // START KGU#197 2016-05-05
    // START KGU#197 2016-07-27
    public final LangTextHolder msgNoSubroutine = 
    		new LangTextHolder("A subroutine diagram %0 (%1 parameters) could not be found!%2Consider starting the Arranger and place needed subroutine diagrams there first.");
    public final LangTextHolder msgInvalidExpr =
    		new LangTextHolder("<%1> is not a correct or existing expression.");
    // START KGU#249 2016-09-17: Bugfix #246 + Issue #243
    public final LangTextHolder msgInvalidBool =
    		new LangTextHolder("<%1> is not a valid Boolean expression.");
    // END KGU#249 2016-09-17
    public final LangTextHolder msgIllFunction =
    		new LangTextHolder("<%1> is not a correct function!");
    public final LangTextHolder msgManualBreak =
    		new LangTextHolder("Manual Break!");
    public final LangTextHolder msgIllegalLeave =
    		new LangTextHolder("Illegal leave argument: %1");
    public final LangTextHolder msgWrongExit =
    		new LangTextHolder("Wrong exit value: %1");
    public final LangTextHolder msgExitCode =
    		new LangTextHolder("Program exited with code %1!");
    public final LangTextHolder msgIllegalJump =
    		new LangTextHolder("Illegal content of a Jump (i.e. exit) instruction: <%1>!");
    public final LangTextHolder msgTooManyLevels =
    		new LangTextHolder("Too many levels to leave (actual depth: %1 / specified: %2)!");
    // END KGU#197 2016-07-27
    // START KGU#247 2016-09-17: Issue #243
    public final LangTextHolder msgJumpOutParallel =
    		new LangTextHolder("Illegal attempt to jump out of a parallel thread:%Thread killed!");
    public final LangTextHolder msgTitleError =
    		new LangTextHolder("Error");
    public final LangTextHolder msgTitleParallel =
    		new LangTextHolder("Parallel Execution Problem");
    public final LangTextHolder msgTitleQuestion =
    		new LangTextHolder("Question");
    // END KGU#247 2016-09-17
    
    // START KGU#68 2015-11-06: Register variable value editing events
    private Object[] varUpdates = null;
    private boolean varsUpdated = false;

    @Override
	public void propertyChange(PropertyChangeEvent pcEv) {
		// Check if it was triggered by the termination of some editing activity (i.e. the cell editor was dropped)
    	if (pcEv.getSource() == this.tblVar && pcEv.getPropertyName().equals("tableCellEditor") && pcEv.getNewValue() == null)
    	{
    		int rowNr = tblVar.getSelectedRow();
            DefaultTableModel tm = (DefaultTableModel) tblVar.getModel();
            Object val = tm.getValueAt(rowNr, 1);
            if (val != null)
            {
            	varsUpdated = true;
            	varUpdates[rowNr] = val;
            	//System.out.println(tm.getValueAt(rowNr, 0).toString() + " <- " + val.toString());
            }
    	}
		
	}
    // END KGU#68 2015-11-06

	// START KGU#117 2016-03-08: Enh. #77
	@Override
	public void itemStateChanged(ItemEvent itEv) {
		if (itEv.getSource() == this.chkCollectRuntimeData)
    	{
    		if (itEv.getStateChange() == ItemEvent.SELECTED)
    		{
    			Element.E_COLLECTRUNTIMEDATA = true;
    			this.cbRunDataDisplay.setEnabled(this.chkCollectRuntimeData.isEnabled());
        		if (Arranger.hasInstance())
        		{
        			Arranger.getInstance().redraw();
        		}
        		Executor.getInstance().redraw();
    		}
    		else if (itEv.getStateChange() == ItemEvent.DESELECTED)
    		{
    			boolean wipeTestStatus = Element.E_COLLECTRUNTIMEDATA;
    			Element.E_COLLECTRUNTIMEDATA = false;
    			this.cbRunDataDisplay.setEnabled(false);
    			if (wipeTestStatus) 
    			{
    				Executor.getInstance().clearPoolExecutionStatus();
    			}
    		}
    		if (Arranger.hasInstance())
    		{
    			Arranger.getInstance().doButtons();
    		}
    	}
    	else if (itEv.getSource() == this.cbRunDataDisplay)
    	{
    		RuntimeDataPresentMode oldShowMode = Element.E_RUNTIMEDATAPRESENTMODE;
    		Element.E_RUNTIMEDATAPRESENTMODE = (RuntimeDataPresentMode)itEv.getItem();
    		if (oldShowMode != Element.E_RUNTIMEDATAPRESENTMODE)
    		{
        		if (Arranger.hasInstance())
        		{
        			Arranger.getInstance().redraw();
        		}
        		Executor.getInstance().redraw();
    		}
    	}
	    // START KGU#160 2016-04-12: Enh. #137 - Checkbox for text window output
    	else if (itEv.getSource() == this.chkOutputToTextWindow)
    	{
    		Executor.getInstance().setOutputWindowEnabled(this.chkOutputToTextWindow.isSelected());
    	}
	    // END KGU#160 2016-04-12
	}
	// END KGU#117 2016-03-08
}
